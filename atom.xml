<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kedl.github.io/</id>
    <title>Danny</title>
    <updated>2019-07-05T02:58:41.956Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kedl.github.io/"/>
    <link rel="self" href="https://kedl.github.io//atom.xml"/>
    <subtitle>爱测试爱Danny</subtitle>
    <logo>https://kedl.github.io//images/avatar.png</logo>
    <icon>https://kedl.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Danny</rights>
    <entry>
        <title type="html"><![CDATA[MySQL 5.7 only full group by解决方案]]></title>
        <id>https://kedl.github.io//post/mysql-57-only-full-group-by-jie-jue-fang-an</id>
        <link href="https://kedl.github.io//post/mysql-57-only-full-group-by-jie-jue-fang-an">
        </link>
        <updated>2019-07-05T02:52:23.000Z</updated>
        <content type="html"><![CDATA[<p>因为MySQL 5.7版本的变化，在执行group by 时，如果后面的列名没有出现在select中则会出现该错误。
解决办法：</p>
<ul>
<li>先查看sql_mode:</li>
</ul>
<pre><code class="language-mysql">select @@global.sql_mode;
</code></pre>
<ul>
<li>去掉ONLY_FULL_GROUP_BY，重新设置值:</li>
</ul>
<pre><code class="language-mysql">set @@global.sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
</code></pre>
<blockquote>
<p>上面是改变了全局sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行：</p>
</blockquote>
<pre><code class="language-mysql">set sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium1和Selenium2的区别]]></title>
        <id>https://kedl.github.io//post/what-the-difference-between-selenium1-and-selenium2</id>
        <link href="https://kedl.github.io//post/what-the-difference-between-selenium1-and-selenium2">
        </link>
        <updated>2019-06-24T04:19:44.000Z</updated>
        <content type="html"><![CDATA[<p>Selenium 1.0包括：selenium IDE、selenium Grid、selenium RC三部分</p>
<blockquote>
<p>selenium IDE：firefox的一个插件，可以录制和回放脚本。
selenium Grid：用于实现分布式测试。利用Grid，可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例。
selenium RC：selenium 的核心部分，可以实现利用selenium的代理服务器来实现访问浏览器实现自动化测试。其中：RC分为Client和Server两部分，Client实现自动化脚本，Server控制浏览器行为。Server又分为三部分：Launcher（启动浏览器）、HTTP Proxy（代理）、Core（嵌入到浏览器的JS代码）。由Launcher启动浏览器，将Core嵌入到浏览器，并把浏览器代理设置为Selenium server的HTTP Proxy。<img src="https://kedl.github.io//post-images/1562294606787.png" alt="">
Selenium 1.0使用的是Javascript注入技术与浏览器打交道，需要SeleniumRC启动一个Server，将操作Web元素的API调用转化为一段段Javascript，在Selenium内核启动浏览器之后注入这段Javascript。开发过Web应用的人都知道，Javascript可以获取并调用页面的任何元素，自如的进行操作。由此才实现了Selenium的目的：自动化Web操作。这种Javascript注入技术的缺点是速度不理想，而且稳定性大大依赖于Selenium内核对API翻译成的Javascript质量高低。</p>
</blockquote>
<p>Selenium 2.0 则是把selenium 1.0中selenium RC替换为了WebDriver</p>
<blockquote>
<p>selenium RC 在浏览器中运行JavaScript应用，使用浏览器内置的JavaScript 翻译器来翻译和执行selenese命令（selenese 是selenium命令集合）。
WebDriver利用浏览器原生的API，封装成一套更加面向对象的SeleniumWebDriverAPI，直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的）。
由于使用的是浏览器原生的API，速度大大提高，而且调用的稳定性交给了浏览器厂商本身，显然是更加科学。然而带来的一些副作用就是，不同的浏览器厂商，对Web元素的操作和呈现多少会有一些差异，这就直接导致了SeleniumWebDriver要分浏览器厂商不同，而提供不同的实现。例如Firefox就有专门的FirefoxDriver，Chrome就有专门的ChromeDriver等等。</p>
</blockquote>
]]></content>
    </entry>
</feed>